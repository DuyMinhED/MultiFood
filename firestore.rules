rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      // Ai cũng có thể đọc
      allow read: if true;
      // Chỉ người đã đăng nhập mới được tạo
      allow create: if request.auth != null;
      // Chủ sở hữu có thể update toàn bộ
      // Hoặc bất kỳ authenticated user nào cũng có thể update followerCount/followingCount (để hỗ trợ follow/unfollow)
      allow update: if request.auth != null && (
        // Chủ sở hữu có thể update toàn bộ
        request.auth.uid == userId
        ||
        // Hoặc chỉ update followerCount/followingCount (cho phép follow/unfollow)
        // Khi dùng SetOptions.merge() với FieldValue.increment(), chỉ các field được chỉ định mới thay đổi
        // Kiểm tra: chỉ followerCount hoặc followingCount được thay đổi (có thể có updatedAt)
        (('followerCount' in request.resource.data.diff(resource.data).affectedKeys() 
           || 'followingCount' in request.resource.data.diff(resource.data).affectedKeys())
         && !('id' in request.resource.data.diff(resource.data).affectedKeys())
         && !('name' in request.resource.data.diff(resource.data).affectedKeys())
         && !('email' in request.resource.data.diff(resource.data).affectedKeys())
         && !('username' in request.resource.data.diff(resource.data).affectedKeys())
         && !('phoneNumber' in request.resource.data.diff(resource.data).affectedKeys())
         && !('avatarUrl' in request.resource.data.diff(resource.data).affectedKeys())
         && !('bio' in request.resource.data.diff(resource.data).affectedKeys())
         && !('isVerified' in request.resource.data.diff(resource.data).affectedKeys())
         && !('postCount' in request.resource.data.diff(resource.data).affectedKeys())
         && !('totalLikesReceived' in request.resource.data.diff(resource.data).affectedKeys())
         && !('createdAt' in request.resource.data.diff(resource.data).affectedKeys()))
      );
      allow delete: if request.auth.uid == userId;
    }

    // ============================================
    // RESTAURANTS COLLECTION (ROOT LEVEL)
    // ============================================
    match /restaurants/{restaurantId} {
      // Ai cũng có thể đọc
      allow read: if true;
      // Chỉ người đã đăng nhập mới được tạo
      allow create: if request.auth != null;
      // Người đã đăng nhập có thể cập nhật (hoặc chỉ chủ sở hữu: request.auth.uid == resource.data.createdBy)
      allow update: if request.auth != null;
      // Không cho phép xóa (hoặc chỉ admin)
      allow delete: if false;
    }

    // ============================================
    // POSTS COLLECTION
    // ============================================
    match /posts/{postId} {
      // Ai cũng có thể đọc bài viết
      allow read: if true;
      // Chỉ người đã đăng nhập mới được tạo
      allow create: if request.auth != null;
      // Chỉ chủ sở hữu mới được sửa (update) hoặc xóa
      allow update, delete: if request.auth.uid == resource.data.userId;

      // ============================================
      // POSTS SUB-COLLECTIONS
      // ============================================
      
      // Images sub-collection
      match /images/{imageId} {
        // Ai cũng có thể đọc ảnh
        allow read: if true;
        // Chỉ chủ sở hữu bài viết mới được tạo/sửa/xóa ảnh
        // Hỗ trợ batch write: Khi tạo post mới, post chưa tồn tại nhưng sẽ được tạo cùng lúc trong batch
        // Firestore batch writes được xử lý atomic, nên ta cho phép create image khi:
        // 1. Post đã tồn tại và user là owner, HOẶC
        // 2. Post chưa tồn tại (đang trong batch write tạo post mới)
        // Lưu ý: Trong batch write, post sẽ được tạo trước images trong cùng batch, nên rule này an toàn
        allow create: if request.auth != null && (
          // Case 1: Post đã tồn tại và user là owner
          (exists(/databases/$(database)/documents/posts/$(postId)) 
            && get(/databases/$(database)/documents/posts/$(postId)).data.userId == request.auth.uid)
          ||
          // Case 2: Đang tạo post mới trong batch write (post chưa tồn tại nhưng sẽ được tạo cùng lúc)
          // Batch write đảm bảo atomic, nên post sẽ được tạo trước images
          (!exists(/databases/$(database)/documents/posts/$(postId)))
        );
        // Update và delete chỉ khi post đã tồn tại và user là owner
        allow update, delete: if request.auth != null 
          && exists(/databases/$(database)/documents/posts/$(postId))
          && get(/databases/$(database)/documents/posts/$(postId)).data.userId == request.auth.uid;
      }

      // Likes sub-collection
      match /likes/{userId} {
        // Ai cũng có thể đọc likes
        allow read: if true;
        // Chỉ người dùng đó mới được tạo/sửa/xóa like của mình
        allow create, update, delete: if request.auth != null && request.auth.uid == userId;
      }

      // Comments sub-collection
      match /comments/{commentId} {
        // Ai cũng có thể đọc comments
        allow read: if true;
        // Chỉ người đã đăng nhập mới được tạo comment
        allow create: if request.auth != null;
        // Chỉ chủ bình luận mới được sửa/xóa
        allow update, delete: if request.auth.uid == resource.data.userId;
      }
    }

    // ============================================
    // ROOT LIKES COLLECTION (used for quick lookups)
    // ============================================
    match /likes/{likeId} {
      // Người dùng chỉ đọc được những like của chính mình
      // Cho phép đọc document không tồn tại (cần cho Transaction.get() khi document chưa có)
      // Format likeId: "{userId}_{postId}"
      // Lưu ý: Khi document không tồn tại, resource.data sẽ null
      // Transaction cần đọc để check exists(), nên ta cho phép đọc nếu:
      // 1. Document tồn tại và userId khớp, HOẶC
      // 2. Document không tồn tại và likeId có format đúng (bắt đầu với userId + '_')
      // Để check format: likeId phải bắt đầu với userId + '_'
      // Sử dụng string comparison: likeId >= userId + '_' && likeId < userId + '`'
      // (backtick '`' là ký tự ngay sau underscore '_' trong ASCII, đảm bảo likeId bắt đầu đúng)
      // Đơn giản hóa: Cho phép đọc nếu likeId format đúng (bắt đầu với userId + '_')
      // Điều này an toàn vì user chỉ có thể đọc like của chính mình
      allow read: if request.auth != null && (
        // Case 1: Document tồn tại và userId khớp
        (resource.data != null && resource.data.userId == request.auth.uid)
        ||
        // Case 2: Document không tồn tại nhưng likeId format đúng (cho Transaction)
        // Check: likeId phải bắt đầu với userId + '_'
        // Sử dụng string range check: likeId >= userId + '_' && likeId < userId + '`'
        // Điều này đảm bảo likeId bắt đầu với userId + '_' và có ít nhất 1 ký tự sau
        (likeId >= request.auth.uid + '_' && likeId < request.auth.uid + '`')
      );

      // Chỉ chủ sở hữu mới tạo/sửa/xóa được bản ghi like của mình
      allow create, update: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null && resource.data != null && resource.data.userId == request.auth.uid;
    }

    // ============================================
    // FOLLOWS COLLECTION
    // ============================================
    match /follows/{followId} {
      // Ai cũng có thể đọc (để check follow status)
      allow read: if true;
      // Chỉ người đã đăng nhập mới được tạo follow document
      // followId format: "{followerId}_{followingId}"
      allow create: if request.auth != null 
        && request.resource.data.followerId == request.auth.uid
        && followId == request.resource.data.followerId + '_' + request.resource.data.followingId;
      // Không cho phép update (chỉ tạo/xóa)
      allow update: if false;
      // Chỉ follower (người follow) mới được xóa follow document của chính họ
      allow delete: if request.auth != null 
        && resource.data.followerId == request.auth.uid;
    }
  }
}

